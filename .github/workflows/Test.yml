#mettre un fichier du type action.yaml sur scout action
#mettre index.js

name: Test

on:
  # Déclenche le workflow sur les pushes et les pull requests vers la branche 'main'
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev 
  # Permet d'exécuter le workflow manuellement depuis l'onglet Actions
  workflow_dispatch:

jobs:
  build-and-test:
    # Exécuter sur la dernière version d'Ubuntu
    runs-on: ubuntu-latest
    
    # Récupérer les secrets nécessaires pour l'environnement
    # Assurez-vous que ces variables sont configurées dans les GitHub Secrets du repo
    env:
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      POSTGRES_URL: ${{ secrets.POSTGRES_URL }}
      # Le nom d'hôte de la DB dans le réseau Docker Compose est 'postgres'
      TEST_DB_HOST: postgres

    steps:
      # Étape 1: Cloner le dépôt
      - name: Checkout repository
        uses: actions/checkout@v4
      # ...other setup steps

      # Installer Docker Compose
      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose version
  # ...docker-compose usage steps
      # Étape 2: Configurer Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Étape 3: Construction et démarrage de tous les services avec Docker Compose
      - name: Build and Start Services
        run: |
          echo "POSTGRES_USER=${{ env.POSTGRES_USER }}" > .env
          echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> .env
          echo "POSTGRES_DB=${{ env.POSTGRES_DB }}" >> .env
          echo "POSTGRES_URL=${{ env.POSTRES_URL }}" >> .env
          
          # Démarrer les services en arrière-plan et attendre leur santé
          # La commande '--build' est cruciale pour les services avec un Dockerfile local
          docker-compose -f docker-compose.yml up --build -d

      # Étape 4: Attendre que le service Postgres soit "healthy" et que le seeder ait fini
      - name: Wait for Postgres and Seeder to initialize
        run: |
          echo "Waiting for Postgres healthcheck..."
          # Attendre que la base de données soit prête (pg_isready dans le healthcheck)
          timeout 120 bash -c 'while [[ "$(docker-compose -f docker-compose.yml inspect --format='{{.State.Health.Status}}' postgres 2>/dev/null)" != "healthy" ]]; do sleep 5; done'
          
          echo "Postgres is healthy. Waiting for seeder (postgres_data) to complete..."
          sleep 30
          
          # Vérifier que tous les services sont démarrés sans erreur
          docker-compose ps
          if [ $(docker-compose ps | grep "Exit" | wc -l) -gt 1 ]; then
            echo "Some services failed to start or exited unexpectedly."
            # Afficher les logs des services pour le débogage
            docker-compose logs
            exit 1
          fi

      # Étape 5: Configuration et Exécution du Test d'Intégration BDD (test_BDD.py)
      - name: Run Database Integration Test
        run: |
          echo "--- Running test_BDD.py against the 'postgres' service ---"
          # Installer Python et le driver PostgreSQL
          sudo apt-get update && sudo apt-get install -y python3-dev libpq-dev
          python3 -m pip install psycopg2-binary
          
          
          # Exécuter le test Python en passant les secrets en tant qu'arguments ou variables d'environnement
          python3 test_BDD_ci.py ${{ env.POSTGRES_USER }} ${{ env.POSTGRES_PASSWORD }} ${{ env.POSTGRES_DB }} ${{ env.TEST_DB_HOST }}

      # Étape 6: Nettoyage 
      - name: Cleanup
        if: always() 
        run: |
          echo "Stopping and removing containers and networks..."
          docker-compose -f docker-compose.yml down -v